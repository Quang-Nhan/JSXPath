<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Tokens/JSXPathFunctions.js - JSXPath - xpath query language for JSON documents</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="JSXPath - xpath query language for JSON documents" width="117" height="52">JSXPath - xpath query language for JSON documents</h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 1.2.9</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/JSXAxisTokens.html">JSXAxisTokens</a></li>
                                <li><a href="../classes/JSXOperatorTokens.html">JSXOperatorTokens</a></li>
                                <li><a href="../classes/JSXPath.html">JSXPath</a></li>
                                <li><a href="../classes/JSXPathFunctions.html">JSXPathFunctions</a></li>
                                <li><a href="../classes/JSXProcessor.html">JSXProcessor</a></li>
                                <li><a href="../classes/JSXReplacer.html">JSXReplacer</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/JSXPath.html">JSXPath</a></li>
                                <li><a href="../modules/Parser.html">Parser</a></li>
                                <li><a href="../modules/Processor.html">Processor</a></li>
                                <li><a href="../modules/Tokens.html">Tokens</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: Tokens/JSXPathFunctions.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
var JSXValidator = require(&quot;../Utils/JSXValidator&quot;);
var JSXError = require(&quot;../Utils/JSXError&quot;);
var JSXDebugConfig = require(&quot;../JSXDebugConfig&quot;);

/**
 * JSXPath 
 * =======
 * - [Home](../README.html)
 * - [Axis](AXIS.html)
 * - Functions
 * - [Node Selection](NODESELECTION.html)
 * - [Operators](OPERATORS.html)
 *
 * # Functions
 * [node]() , 
 * [nodeValue]() , 
 * [text]()
 * 
 * 
 * Function expression are used to refine queries or add programming capabilities. JSXPath allows user to add their own custom functions (see TODO)
 *
 * The following function examples will use the JSXPath constructor below as the initial setup.
 * ##### constructor
 * &#x60;&#x60;&#x60;js
 * var js = {
 * 	int: {
 * 		a: 1,
 * 		b: 2
 * 	},
 * 	dec: {
 * 		a: 1.5,
 * 		b: 1.4
 * 	}
 * 	str: {
 * 		st1: &quot;abc&quot;,
 * 		st2: &quot;DE&quot;,
 * 		st3: &quot;efg&quot;,
 * 		tok: &quot;q,u,a,n,g&quot;,
 * 		num: &quot;-10&quot;
 * 	}
 * }
 * var jsxpath = new JSXPath(js);
 * &#x60;&#x60;&#x60;
 * @class JSXPathFunctions
 * @constructor
 */
class JSXPathFunctions {
	constructor(exploded, poCustomFunctions) {
		this.DEBUG = JSXDebugConfig.debugOn;
		this.SHOW_PATH_FUNCTIONS = JSXDebugConfig.showPathFunctions;
		this.Validator = new JSXValidator();
		this.ErrorHandler = new JSXError();
		this.customs = poCustomFunctions;
		this.tokens = {
			/**
			 * ## node //TODO: jasmine
			 * retrieve the current node object containing the following properties { name, value, parent, children }
			 *
			 * [constructor](#constructor)
			 * &#x60;&#x60;&#x60;js
			 * let path = &#x27;/int/*[node() = &#x27;;
			 * let result = jsxpath.process(path);
			 * ==========
			 * // result =&gt; { name: &quot;a&quot;, value: 1, parent: &quot;int&quot;, children: [] }
			 * &#x60;&#x60;&#x60;
			 *
			 * @deprecated
			 * @method node
			 * @return {object} current node object
			 */
			&quot;node&quot;: () =&gt; {
				return this.exploded[&quot;.&quot;];
			  }
			  /**
			   * ## nodeValue //TODO: jasmine
			   * retrieves the value/s of nodes. If no nodes are passed in, then the current node value is returned
			   *
			   * [constructor](#constructor)
			   * &#x60;&#x60;&#x60;js
			   * let path = &#x27;/int/*[nodeValue() = 1]&#x27;;
			   * let result = jsxpath.process(path);
			   * ==========
			   * // result =&gt; [1]
			   * &#x60;&#x60;&#x60;
			   * 
			   * @method nodeValue
			   * @param  {Array} [args]
			   * @return {any|Array&lt;any&gt;} the value of the current node or an array of node values
			   */
			, &quot;nodeValue&quot;: (args) =&gt; {
				// this.ErrorHandler.test(&quot;ArgumentLength&quot;, {name: &quot;node-value()&quot;, data: args.length === 0, at: &quot;JSXPathFunctions:node-value()&quot;});

				if (args.length === 0) {
					return this.exploded[&quot;.&quot;].value;
				}

				var result;
				if (Array.isArray(args[0])) {
					result = this.Validator.validateNode(args[0][0], &quot;nodeValue()&quot;, true);
				} else {
					result = this.Validator.validateNode(args[0], &quot;nodeValue()&quot;, true);
				}
				return result;
			  }
			/**
			 * ## text //TODO:jasmine
			 * retrieves the string formatted of nodes value/s. If no nodes are passed in, then the current node value text is returned
			 *
			 * [constructor](#constructor)
			 * &#x60;&#x60;&#x60;js
			 * let path = &#x27;&#x27;;
			 * let result = jsxpath.process(path);
			 * ==========
			 * // result =&gt; 
			 * &#x60;&#x60;&#x60;
			 * 
			 * @method text
			 * @param  {Array} [args]
			 * @return {any|Array&lt;any&gt;} the value of the current node or an array of node values
			 */
			, &quot;text&quot;: (args) =&gt; {
				if (args.length === 0)
					return JSON.stringify(this.exploded[&quot;.&quot;].value);
				var result;
				if (Array.isArray(args[0])) {
					result = JSON.stringify(this.Validator.validateNode(args[0][0], &quot;nodeValue()&quot;, true));
				} else {
					result = JSON.stringify(this.Validator.validateNode(args[0], &quot;nodeValue()&quot;, true));
				}
				return result;
			  }
			/**
			 * ## contains
			 * validates that the source string contains the search string
			 *
			 * [constructor](#constructor)
			 * &#x60;&#x60;&#x60;js
			 * let path = &#x27;contains(/str/st2, &quot;E&quot;)&#x27;;
			 * let result = jsxpath.process(path);
			 * ==========
		 	 * // result =&gt; true
			 * &#x60;&#x60;&#x60; 
			 * 
			 * &#x60;&#x60;&#x60;js
			 * let path = &#x27;contains(/str/st2, &quot;e&quot;)&#x27;;
			 * let result = jsxpath.process(path);
			 * ==========
		 	 * // result =&gt; false
			 * &#x60;&#x60;&#x60;
			 * 
			 * @method contains
			 * @param  {Array&lt;String&gt;} args - two arguments: [0] source string, [1] search string
			 * @return {Boolean} true of the source string contains the search string
			 */
			, &quot;contains&quot;: (args) =&gt; {
				this.ErrorHandler.test(&quot;ArgumentLength&quot;, {name: &quot;contains()&quot;, data: args.length !== 2, at: &quot;JSXPathFunctions:contains()&quot;});

				let source = this.Validator.validateString(args[0], &quot;contains()&quot;, true);
				let search = this.Validator.validateString(args[1], &quot;contains()&quot;, true);
				return source.indexOf(search) &gt; -1;
			  }
			/**
			 * ## concat
			 * combines a set of strings and return the resulting string.
			 *
			 * [constructor](#constructor)
			 * &#x60;&#x60;&#x60;js
		  	 * let path = &#x27;concat(/str/st1, /str/st2, /str/st3, &quot; ZYW&quot;)&#x27;;
			 * let result = jsxpath.process(path);
		  	 * ==========
			 * // result =&gt; &quot;abcDEfgh ZYW&quot;
			 * &#x60;&#x60;&#x60;
			 * 
			 * @method concat
			 * @param  {Array&lt;String&gt;} args
			 * @return {String} the combined string
			 */
			, &quot;concat&quot;: (args) =&gt; {
				this.ErrorHandler.test(&quot;ArgumentLength&quot;, {name: &quot;concat()&quot;, data: args.length === 0, at: &quot;JSXPathFunctions:concat()&quot;});

				let sVal = &quot;&quot;, self = this;
				for (let i = 0; i &lt; args.length; i++) {
					sVal += this.Validator.validateString(args[i], &quot;concat()&quot;, true);
				}
				return sVal;
			  }
			/**
			 * ## substring
			 * returns the substring of the source string given the starting index and optional substring length.
			 *
			 * [constructor](#constructor)
			 * &#x60;&#x60;&#x60;js
			 * let path = &#x27;substring(/str/st1, 1)&#x27;;
			 * let result = jsxpath.process(path);
			 * ==========
			 * // result =&gt; bc
			 * &#x60;&#x60;&#x60; 
			 * 
			 * &#x60;&#x60;&#x60;js
			 * let path = &#x27;substring(/str/st1, 1, 1)&#x27;;
			 * let result = jsxpath.process(path);
			 * ==========
			 * // result =&gt; b
			 * &#x60;&#x60;&#x60;
			 * 
			 * @method substring
			 * @param  {Array} args - two or three arguments: [0] source string, [1] start index number, [2] substring length number (optional)
			 * @return {String} the combined string
			 */
			, &quot;substring&quot;: (args) =&gt; {
				this.ErrorHandler.test(&quot;ArgumentLength&quot;,{name: &quot;substring()&quot;, data: args.length &lt; 2 || args.length &gt; 3, at: &quot;JSXPathFunctions:substring()&quot;});

				let source = this.Validator.validateString(args[0], &quot;substring()&quot;, true);
				let start = this.Validator.validateNumber(args[1], &quot;substring()&quot;, true);
				let length = args[2] ? this.Validator.validateNumber(args[2], &quot;substring()&quot;, true) : null;
				let aArgs = [start];
				if (length) {
					aArgs.push(length + start);
				}
				return source.substring.apply(source, aArgs);
			  }
			/**
			 * ## substring-before
			 * returns the substring-before of the source string before the start of the search string.
			 *
			 * [constructor](#constructor)
			 * &#x60;&#x60;&#x60;js
			 * let path = &#x27;substring-before(/str/st3, &quot;f&quot;)&#x27;;
			 * let result = jsxpath.process(path);
			 * ==========
			 * // result =&gt; &quot;e&quot;
			 * &#x60;&#x60;&#x60;
			 * 
			 * @method substringBefore
			 * @param  {Array} args - two arguments: [0] source string, [1] search string
			 * @return {String} the substring before the start of the search string
			 */
			, &quot;substringBefore&quot;: (args) =&gt; {
				this.ErrorHandler.test(&quot;ArgumentLength&quot;, {name: &quot;substring-before()&quot;, data: args.length !== 2, at: &quot;JSXPathFunctions:substring-before()&quot;});

				let source = this.Validator.validateString(args[0], &quot;substring-after()&quot;, true);
				let search = this.Validator.validateString(args[1], &quot;substring-after()&quot;, true);
				let index = source.search(search);
				return source.substring(0, index); 
			  }
			/**
			 * ## substring-after
			 * returns the substring-after of the source string after the end of the search string.
			 *
			 * [constructor](#constructor)
			 * &#x60;&#x60;&#x60;js
			 * let path = &#x27;substring-after(/str/st3, &quot;f&quot;)&#x27;;
			 * let result = jsxpath.process(path);
			 * ==========
			 * // result =&gt; &quot;g&quot;
			 * &#x60;&#x60;&#x60;
			 * 
			 * @method substringAfter
			 * @param  {Array} args - two arguments: [0] source string, [1] search string
			 * @return {String} the substring after the end of the search string
			 */
			, &quot;substringAfter&quot;: (args) =&gt; {
				this.ErrorHandler.test(&quot;ArgumentLength&quot;, {name: &quot;substring-after()&quot;, data: args.length !== 2, at: &quot;JSXPathFunctions:substring-after()&quot;});

				let source = this.Validator.validateString(args[0], &quot;substring-after()&quot;, true);
				let search = this.Validator.validateString(args[1], &quot;substring-after()&quot;, true);
				let index = source.search(search) + search.length;
				return source.substring(index);
			  }
			/**
			 * ## translate //TODO: jasmine
			 * returned the tranformed string given a &#x27;from&#x27; list of characters to the &#x27;to&#x27; list of characters.
			 *
			 * [constructor](#constructor)
			 * &#x60;&#x60;&#x60;js
			 * let path = &#x27;translate(&quot;abDE EDfg&quot;, &quot;DE&quot;, &quot;de&quot;)&#x27;;
			 * let result = jsxpath.process(path);
			 * ==========
			 * // result =&gt; &quot;abde edfg&quot;
			 * &#x60;&#x60;&#x60;
			 * 
			 * @method translate
			 * @param  {Array} args - three arguments: [0] source string, [1] from string of characters, [2] to string of characters
			 * @return {String} the translated string
			 */
			, &quot;translate&quot;: (args) =&gt; {
				this.ErrorHandler.test(&quot;ArgumentLength&quot;, {name: &quot;translate()&quot;, data: args.length !== 3, at: &quot;JSXPathFunctions:translate()&quot;});

				let source = this.Validator.validateString(args[0], &quot;translate()&quot;, true);
				let from = this.Validator.validateString(args[1], &quot;translate()&quot;, true);
				let to = this.Validator.validateString(args[2], &quot;translate()&quot;, true);
				if (from.length &lt; to.length) {
					to = to.substring(0, from.length);
				} else if (from.length &gt; to.length) {
					from = from.substring(0, to.length);
				}

				var result = source;
				for (let i = 0; i &lt; from.length; ++i) {
					result = result.replace(new RegExp(from[i], &quot;g&quot;), to[i]);
				}
				return result;
			  }
			/**
			 * ## string-length
			 * returns the length of a given string.
			 *  
			 * &#x60;&#x60;&#x60;js
			 * let path = &#x27;string-length(/str/st2)&#x27;;
			 * let result = jsxpath.process(path);
			 * ==========
			 * // result =&gt; 2
			 * &#x60;&#x60;&#x60;
			 * 
			 * @method stringLength
			 * @param  {Array} args - one argument: [0] source string
			 * @return {Number} the length of the string
			 */
			, &quot;stringLength&quot;: (args) =&gt; {
				this.ErrorHandler.test(&quot;ArgumentLength&quot;, {name: &quot;string-length()&quot;, data: args.length !== 1, at: &quot;JSXPathFunctions:string-length()&quot;});

				let source = this.Validator.validateString(args[0], &quot;string-length()&quot;, true);
				return source.length;
			  }
			/**
			 * ## matches
			 * returns true if the source string matches a string/regex pattern.
			 *
			 * [constructor](#constructor)
			 * &#x60;&#x60;&#x60;js
			 * let path = &#x27;matches(/str/st2, &quot;^D&quot;)&#x27;;
			 * let result = jsxpath.process(path);
			 * ==========
			 * // result =&gt; true
			 * &#x60;&#x60;&#x60;
			 * 
			 * @method matches
			 * @param  {Array} args - two arguments: [0] source string, [1] pattern string/regex
			 * @return {Boolean} a list of matched substring
			 */
			, &quot;matches&quot;: (args) =&gt; {
				this.ErrorHandler.test(&quot;ArgumentLength&quot;, {name: &quot;matches()&quot;, data: args.length !== 2, at: &quot;JSXPathFunctions:matches()&quot;});

				let source = this.Validator.validateString(args[0], &quot;matches()&quot;, true);
				let pattern = this.Validator.validateString(args[1], &quot;matches()&quot;, true);
				let match = source.match(new RegExp(pattern));

				return Array.isArray(match);
			  }
			/**
			 * ## replace
			 * Replaces substring matching a string/pattern with the replacement string and returns the result.
			 *  
			 * &#x60;&#x60;&#x60;js
			 * let path = &#x27;replace(/str/st3, &quot;[\w]g&quot;, &quot;F&quot;)&#x27;;
			 * let result = jsxpath.process(path);
			 * ==========
			 * // result =&gt; &quot;eF&quot;
			 * &#x60;&#x60;&#x60;
			 * 
			 * @method replace
			 * @param  {Array} args - three arguments: [0] source string, [1] pattern string/regex, [2] replacement string
			 * @return {String} the transformed string
			 */
			, &quot;replace&quot;: (args) =&gt; {
				this.ErrorHandler.test(&quot;ArgumentLength&quot;, {name: &quot;replace()&quot;, data: args.length !== 3, at: &quot;JSXPathFunctions:replace()&quot;});

				let source = this.Validator.validateString(args[0], &quot;replace()&quot;, true);
				let pattern = this.Validator.validateString(args[1], &quot;replace()&quot;, true);
				let replacement = this.Validator.validateString(args[2], &quot;replace()&quot;, true);
				return source.replace(new RegExp(pattern, &quot;g&quot;), replacement); 
			  }
			/**
			 * ## tokenize
			 * Splits the string based on the token pattern specified
			 *
			 * [constructor](#constructor)
			 * &#x60;&#x60;&#x60;js
			 * let path = &#x27;tokenize(/str/tok, &quot;,&quot;)&#x27;;
			 * let result = jsxpath.process(path);
			 * ==========
			 * // result =&gt; [&quot;q&quot;, &quot;u&quot;, &quot;a&quot;, &quot;n&quot;, &quot;g&quot;]
			 * &#x60;&#x60;&#x60;
			 * 
			 * @method tokenize
			 * @param  {Array} args - two arguments: [0] source string, [1] pattern string/regex
			 * @return {Array&lt;String&gt;} a list of splitted strings
			 */
			, &quot;tokenize&quot;: (args) =&gt; {
				this.ErrorHandler.test(&quot;ArgumentLength&quot;, {name: &quot;tokenize()&quot;, data: args.length !== 2, at: &quot;JSXPathFunctions:tokenize()&quot;});

				let source = this.Validator.validateString(args[0], &quot;tokenize()&quot;, true);
				let pattern = this.Validator.validateString(args[1], &quot;tokenize()&quot;, true);
				let result =  source.split(new RegExp(pattern));
				for (var i = 0; i &lt; result.length; ++i) {
					if (result[i] !== &quot;&quot;)
						return result;
				}
				throw new Error (&quot;thrown in function tokenize(), pattern matches zero-length string.&quot;); 
			  }
			/**
			 * ## round
			 * Round a decimal number to it&#x27;s nearest integer. If the decimal is greater than or equal to x.5, it will round up otherwise round down
			 *
			 * [constructor](#constructor)
			 * &#x60;&#x60;&#x60;js
			 * let path = &#x27;round(/dec/a)&#x27;;
			 * let result = jsxpath.process(path);
			 * ==========
			 * // result =&gt; 2
			 * &#x60;&#x60;&#x60;
			 * 
			 * &#x60;&#x60;&#x60;js
			 * let path = &#x27;round(/dec/b)&#x27;;
			 * let result = jsxpath.process(path);
			 * ==========
			 * // result =&gt; 1
			 * &#x60;&#x60;&#x60;
			 * 
			 * @method round
			 * @param  {Array} args - one arguments: [0] source number
			 * @return {Number} the rounded integer value
			 */
			, &quot;round&quot;: (args) =&gt; {
				this.ErrorHandler.test(&quot;ArgumentLength&quot;, {name: &quot;round()&quot;, data: args.length !== 1, at: &quot;JSXPathFunctions:round()&quot;});

				let source = this.Validator.validateNumber(args[0], &quot;round()&quot;, true);
				return Math.round(source);
			  }
			/**
			 * ## floor
			 * Floor a decimal number to it&#x27;s largest integer less than or equal to a given number.
			 *
			 * [constructor](#constructor)
			 * &#x60;&#x60;&#x60;js
			 * let path = &#x27;floor(/dec/b)&#x27;;
			 * let result = jsxpath.process(path);
			 * ==========
			 * // result =&gt; 1
			 * &#x60;&#x60;&#x60;
			 * 
			 * @method floor
			 * @param  {Array} args - one arguments: [0] source number
			 * @return {Number} the floored integer value
			 */
			, &quot;floor&quot;: (args) =&gt; {
				this.ErrorHandler.test(&quot;ArgumentLength&quot;, {name: &quot;floor()&quot;, data: args.length !== 1, at: &quot;JSXPathFunctions:floor()&quot;});

				let source = this.Validator.validateNumber(args[0], &quot;floor()&quot;, true);
				return Math.floor(source);
			  }
			/**
			 * ## ceiling
		  	 * Ceiling a decimal number to it&#x27;s smallest integer greater than or equal to a given number.
			 *
			 * [constructor](#constructor)
			 * &#x60;&#x60;&#x60;js
			 * let path = &#x27;ceiling(/dec/a)&#x27;;
			 * let result = jsxpath.process(path);
			 * ==========
			 * // result =&gt; 2
			 * &#x60;&#x60;&#x60;
			 * 
			 * @method ceiling
			 * @param  {Array} args - one arguments: [0] source number
			 * @return {Number} the ceiling integer value
			 */
			, &quot;ceiling&quot;: (args) =&gt; {
				this.ErrorHandler.test(&quot;ArgumentLength&quot;, {name: &quot;ceiling()&quot;, data: args.length !== 1, at: &quot;JSXPathFunctions:ceiling()&quot;});

				let source = this.Validator.validateNumber(args[0], &quot;ceiling()&quot;, true);
				return Math.ceil(source);
			  }
			  /**
			   * ## count
			   * Returns the number of nodes in a node set.
			   *
			   * [constructor](#constructor)
			   * &#x60;&#x60;&#x60;js
			   * let path = &#x27;&#x27;;
			   * let result = jsxpath.process(path);
			   * ==========
			   * // result =&gt; 
			   * &#x60;&#x60;&#x60;
			   * 
			   * @method count
			   * @param  {Array} args - one arguments: [0] source number
			   * @return {Number} the number of nodes
			   */
			, &quot;count&quot;: () =&gt; {

			  }
			/**
			 * ## sum //TODO: jasmine
			 * Returns the sum of numbers and/or nodes that contains number value.
			 *
			 * [constructor](#constructor)
			 * &#x60;&#x60;&#x60;js
			 * let path = &#x27;sum(/int/a, /int/b)&#x27;;
			 * let result = jsxpath.process(path);
			 * ==========
			 * // result =&gt; 3
			 * &#x60;&#x60;&#x60;
			 * 
			 * @method sum
			 * @param  {Array&lt;Number|Object&gt;} [args]
			 * @return {Number} the summation result
			 */
			, &quot;sum&quot;: (args) =&gt; { //TODO! duration with time/date
				/* istanbul ignore if */
				if (this.DEBUG &amp;&amp; this.SHOW_PATH_FUNCTIONS) console.log(new Date(), &quot;JSXPathFunctions:sum:args&quot;, args);
				// this.ErrorHandler.test(&quot;ArgumentLength&quot;, {name: &quot;sum()&quot;, data: args.length === 0, at: &quot;JSXPathFunctions:sum()&quot;});

				let aNums = [];
				for (let i = 0; i &lt; args.length; ++i) {
					let arg = this.Validator.isArray(args[i], &quot;sum()&quot;);
					if (!arg) {
						arg = this.Validator.validateNumber(args[i], &quot;sum()&quot;);
					}
					Array.isArray(arg) ? aNums = aNums.concat(arg) : aNums.push(arg);
				}

				let sum = 0;
				for (let j = 0; j &lt; aNums.length; ++j) {
					// this.ErrorHandler.test(&quot;DefinedAndValidType&quot;, {name:&quot;aNums[&quot;+j+&quot;]&quot; ,data: aNums[j], expectedType: &quot;number&quot;, type: !isNaN(aNums[j]) &amp;&amp; typeof(aNums[j]) === &quot;number&quot; ? &quot;number&quot;: &quot;NaN&quot;, at: &quot;JSXPathFunctions:sum&quot;})
					if (aNums[j] === null || isNaN(aNums[j])) {
						sum = NaN;
						break;
					}
					sum += aNums[j];
				}

				// istanbul ignore if
				if (this.DEBUG &amp;&amp; this.SHOW_PATH_FUNCTIONS) console.log(new Date(), &quot;JSXPathFunctions:sum:result&quot;, sum);
				return sum;
			  }
			  /**
			   * ## name
			   * the name of the node or the name of the current node if no argument is passed.
			   *
			   * [constructor](#constructor)
			   * &#x60;&#x60;&#x60;js
			   * let path = &#x27;&#x27;;
			   * let result = jsxpath.process(path);
			   * ==========
			   * // result =&gt; 
			   * &#x60;&#x60;&#x60;
			   * 
			   * @method name
			   * @param  {Array} args - one arguments: [0] source number
			   * @return {String} the name of the node
			   */
			, &quot;name&quot;: (args) =&gt; {
				// this.ErrorHandler.test(&quot;ArgumentLength&quot;, {name: &quot;name()&quot;, data: args.length &gt; 1, at: &quot;JSXPathFunctions:name()&quot;});
				if (args.length === 0) {
					return this.exploded[&quot;.&quot;].name;
				}

				var node;
				if (Array.isArray(args[0])) {
					if (!args[0].length) {
						return &quot;&quot;;
					}
					node = this.Validator.validateNode(args[0][0], &quot;name()&quot;, true);
				} else {
					node = this.Validator.validateNode(args[0], &quot;name()&quot;, true);
				}
				return node.name;
			  }
			/**
			 * ## local-name //TODO: jasmine
			 * Returns the current node name.
			 *
			 * [constructor](#constructor)
			 * &#x60;&#x60;&#x60;js
			 * let path = &#x27;/int/*[local-name() = &quot;a&quot;]&#x27;;
			 * let result = jsxpath.process(path);
			 * ==========
			 * // result =&gt; 1
			 * &#x60;&#x60;&#x60;
			 * 
			 * @method localName
			 * @return {String} the current node name.
			 */
			, &quot;localName&quot;: () =&gt; {
				if (this.exploded[&quot;.&quot;].name === &quot;@&quot;)
					return &quot;root&quot;;
				return this.exploded[&quot;.&quot;].name;
			  }
			, last: () =&gt; {
				//if array, returns the last on the list
				//otherwise returns the last child object according to the sorted children list
			  }
			, first: () =&gt; {
				//if array, returns the first on the list
				//otherwise returns the first object according to sorted children list
			  }
			/**
			 * ## number //TODO: jasmine
			 * Converts the value of a node or primitive value to a number. If no arguments is given, the value of the current node is converted to a number if valid.
			 *
			 * [constructor](#constructor)
			 * &#x60;&#x60;&#x60;js
			 * let path = &#x27;number(/str/num)&#x27;;
			 * let result = jsxpath.process(path);
			 * ==========
			 * // result =&gt; -10
			 * &#x60;&#x60;&#x60;
			 * 
			 * @method number
			 * @param  {Array} [args]
			 * @return {Number}
			 */
			, &quot;number&quot;: (args) =&gt; {
				//converts to number. if not a type number, converts to 0;
				this.ErrorHandler.test(&quot;ArgumentLength&quot;, {name: &quot;number()&quot;, data: args.length &gt; 1, at: &quot;JSXPathFunctions:number()&quot;});

				if (args.length === 0) {
					return Number(this.exploded[&quot;.&quot;].value);
				}
				if (args[0] &amp;&amp; args[0].value) {
					return Number(args[0].value);
				}
				return Number(args[0]);
			  }
			/**
			 * ## string
			 * Converts the value of a node or primitive value to a string. If no argument is given, the value of the current node is converted to a string.
			 *
			 * [constructor](#constructor)
			 * &#x60;&#x60;&#x60;js
			 * let path = &#x27;string(/int/b)&#x27;;
			 * let result = jsxpath.process(path);
			 * ==========
			 * // result =&gt; &quot;2&quot;
			 * &#x60;&#x60;&#x60;
			 * 
			 * @method string
		  	 * @param  {Array} [args]
			 * @return {String}
			 */
			, &quot;string&quot;: (args) =&gt; {
				this.ErrorHandler.test(&quot;ArgumentLength&quot;, {name: &quot;string()&quot;, data: args.length &gt; 1, at: &quot;JSXPathFunctions:string()&quot;});

				if (args.length === 0){
					if (this.exploded[&quot;.&quot;].value)
						return this.exploded[&quot;.&quot;].value.toString();
					return &quot;&quot;;
				}
				if (args[0] &amp;&amp; args[0].value) {
					return args[0].value.toString();
				}
				if (&quot;object&quot; !== typeof args[0]) {
					return args[0].toString();
				}
				return &quot;&quot;;
			  }
			/**
			 * ## boolean //TODO code and jasmine
			 * Converts the value of a node or primitive value to a boolean. If no argument is given, the value of the current node is converted to a boolean.
		  	 *
			 * [constructor](#constructor)
		  	 * &#x60;&#x60;&#x60;js
			 * let path = &#x27;boolean(/notExists)&#x27;;
			 * let result = jsxpath.process(path);
			 * ==========
			 * // result =&gt; false
			 * &#x60;&#x60;&#x60;
			 * 
		  	 * &#x60;&#x60;&#x60;js
			 * let path = &#x27;boolean(&#x27;;
			 * let result = jsxpath.process(path);
			 * ==========
			 * // result =&gt; 
			 * &#x60;&#x60;&#x60;
			 * 
			 * @method boolean
			 * @param  {Array} [args]
			 * @return {Boolean}
			 */
			, &quot;boolean&quot;: (args) =&gt; {

			  }
			, &quot;castable-as&quot;: (Value) =&gt; {

			  }
			, &quot;instance-of&quot;: () =&gt; {

			  }
			, &quot;cast-to&quot;: () =&gt; {

			  }
			, &quot;true&quot;: () =&gt;{

			  }
			, &quot;false&quot;: () =&gt; {

			  }
			, &quot;disctinct-values&quot;: () =&gt; {

			 }
			/**
			 * ## not
			 * Negates the boolean value.
			 *
			 * [constructor](#constructor)
			 * &#x60;&#x60;&#x60;js
			 * let path = &#x27;not(/a = /b)&#x27;;
			 * let result = jsxpath.process(path);
			 * ==========
			 * // result =&gt; true
			 * &#x60;&#x60;&#x60;
			 * 
			 * @method not
			 * @param  {Array} args - one arguments: [0] node set or boolean value
			 * @return {Boolean} 
			 */
			, &quot;not&quot;: (args) =&gt; {
				this.ErrorHandler.test(&quot;ArgumentLength&quot;, {name: &quot;not()&quot;, data: args.length !== 1, at: &quot;JSXPathFunctions:not()&quot;});
				let result = this.Validator.validateNode(args[0], &quot;not()&quot;);
				if (!result)
					result = this.Validator.validateBoolean(args[0], &quot;not()&quot;, true);
				return !result;
			}
		}
		this.exploded = exploded;
	}

	tokens() {
		return this.tokens;
	}

	customs() {
		return this.customs
	}

	_outputDebug(mode, where, prev, next, result) {
		/* istanbul ignore next */
		if (this.DEBUG &amp;&amp; this.SHOW_PATH_FUNCTIONS) {
			let args = [new Date(), where, mode === &quot;init&quot; ? &quot;prev&quot; : &quot;prevValue&quot;, prev, mode === &quot;init&quot; ? &quot;next&quot; : &quot;nextValue&quot;, next];
			if (mode !== &quot;init&quot;) {
				args = args.concat([&quot;result&quot;, result]);
			}
			console.log.apply(this, args);
		}
	}
}

module.exports = JSXPathFunctions;
    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
