<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Tokens/JSXOperatorTokens.js - JSXPath - xpath query language for JSON documents</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="JSXPath - xpath query language for JSON documents" width="117" height="52">JSXPath - xpath query language for JSON documents</h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 1.2.9</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/JSXAxisTokens.html">JSXAxisTokens</a></li>
                                <li><a href="../classes/JSXOperatorTokens.html">JSXOperatorTokens</a></li>
                                <li><a href="../classes/JSXPath.html">JSXPath</a></li>
                                <li><a href="../classes/JSXPathFunctions.html">JSXPathFunctions</a></li>
                                <li><a href="../classes/JSXProcessor.html">JSXProcessor</a></li>
                                <li><a href="../classes/JSXReplacer.html">JSXReplacer</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/JSXPath.html">JSXPath</a></li>
                                <li><a href="../modules/Parser.html">Parser</a></li>
                                <li><a href="../modules/Processor.html">Processor</a></li>
                                <li><a href="../modules/Tokens.html">Tokens</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: Tokens/JSXOperatorTokens.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
var JSXValidator = require(&quot;../Utils/JSXValidator&quot;);
var _ = require(&quot;lodash&quot;);
var JSXDebugConfig = require(&quot;../JSXDebugConfig&quot;);
/**
 * JSXPath
 * =======
 * - [Home](../README.html)
 * - [Axis](AXIS.html)
 * - [Functions](FUNCTIONS.html)
 * - [Node Selection](NODESELECTION.html)
 * - Operators
 * 
 * # Operators 
 * ##### [+](#+) , [-](#-2) , [*](#-3) , [div](#div) , [mod](#mod) , [=](#-4) , [!=](#-5) , [&gt;](#gt) , [&lt;](#lt) , [&gt;=](#gt-2) , [&lt;=](#lt-2) , [and](#and) , [or](#or) , [|](#-6)
 * Operators are symbols used to perform operation/tests on its left and right values.
 *
 * The following operator examples will use the JSXPath constructor below as the initial setup.
 * &#x60;&#x60;&#x60;js
 * var JSXPath = require(&quot;JSXPath&quot;);
 * var js = {
 *	a: 1,
 *	b: 2,
 *	c: [3, 4]
 * };
 * var jsxpath = new JSXPath(js); 
 * &#x60;&#x60;&#x60;
 *
 * @module Tokens
 * @class JSXOperatorTokens
 * @constructor
 */
class JSXOperatorTokens {
	/**
	 * @method constructor - Creates operator tokens
	 */
	constructor() {
		this.DEBUG = JSXDebugConfig.debugOn;
		this.SHOW_OPERATOR_TOKENS = JSXDebugConfig.showOperatorTokens;
		this.Validator = new JSXValidator();
		this.tokens = {
			/**
			 * ## ++
			 * summation
			 * 
			 * &#x60;&#x60;&#x60;js
			 * let path = &#x27;9 + /a&#x27;;
			 * let result = jsxpath.process(path);
			 * ----------
			 * // result =&gt; 10
			 * &#x60;&#x60;&#x60;
			 * 
			 * @function +
			 * @param  {object|number} prev - the previous parsed value before &#x60;+&#x60;
			 * @return {function} A function that accepts the next parsed value argument
			 */
			&quot;+&quot;: (prev) =&gt; {
				return (next) =&gt; {
					this._outputDebug(&quot;init&quot;, &quot;JSXOperatorTokens:+&quot;, prev, next);

					let prevValue = this.Validator.validateNumber(prev, &quot;+&quot;);
					let nextValue = this.Validator.validateNumber(next, &quot;+&quot;);

					if (null === prevValue) {
						prevValue = this.Validator.validateString(prev, &quot;+&quot;, true);
					}
					if (null === nextValue) {
						nextValue = this.Validator.validateString(next, &quot;+&quot;, true);
					}

					let result = prevValue + nextValue;
					// istanbul ignore next
					this._outputDebug(&quot;result&quot;, &quot;JSXOperatorTokens:+&quot;, prevValue, nextValue, result);
					return result;
				} 
			},
			/**
			 * ## -
			 * subtraction
			 * 
			 * &#x60;&#x60;&#x60;js
			 * let path = &#x27;/a - /b&#x27;;
			 * let result = jsxpath.process(path);
			 * ----------
			 * // result =&gt; -1
			 * &#x60;&#x60;&#x60;
			 * 
			 * @function ¬
			 * @param  {object|number} prev - the previous parsed value before &#x60;+&#x60;
			 * @return {function} A function that accepts the next parsed value argument
			 */
			&quot;¬&quot;: (prev) =&gt; {
				return (next) =&gt; {
					this._outputDebug(&quot;init&quot;, &quot;JSXOperatorTokens:-&quot;, prev, next);

					let prevValue = this.Validator.validateNumber(prev, &quot;-&quot;, true);
					let nextValue = this.Validator.validateNumber(next, &quot;-&quot;, true);

					let result = prevValue - nextValue;
					// istanbul ignore next
					this._outputDebug(&quot;result&quot;, &quot;JSXOperatorTokens:-&quot;, prevValue, nextValue, result);
					return result;
				}
			},
			/**
			 * ## *
			 * multiply
			 * 
			 * &#x60;&#x60;&#x60;js
			 * let path = &#x27;/c[2] * /b&#x27;;
			 * let result = jsxpath.process(path);
			 * ---------
			 * // result =&gt; 8
			 * &#x60;&#x60;&#x60;
			 * 
			 * @function ~
			 * @param  {object|number} prev - the previous parsed value before &#x60;+&#x60;
			 * @return {function} A function that accepts the next parsed value argument
			 */
			&quot;~&quot;: (prev) =&gt; {
				return (next) =&gt; {
					this._outputDebug(&quot;init&quot;, &quot;JSXOperatorTokens:*&quot;, prev, next);

					let prevValue = this.Validator.validateNumber(prev, &quot;*&quot;, true);
					let nextValue = this.Validator.validateNumber(next, &quot;*&quot;, true);
					let result = prevValue * nextValue;
					// istanbul ignore next
					this._outputDebug(&quot;result&quot;, &quot;JSXOperatorTokens:*&quot;, prevValue, nextValue, result);
					return result;
				}
			},
			/**
			 * ## div
			 * division
			 * 
			 * &#x60;&#x60;&#x60;js
			 * let path = &#x27;20 div /b&#x27;;
			 * let result = jsxpth.process(path);
			 * ---------
			 * // result =&gt; 10
			 * &#x60;&#x60;&#x60;
			 * 
			 * @function ÷
			 * @param  {object|number} prev - the previous parsed value before &#x60;+&#x60;
			 * @return {function} A function that accepts the next parsed value argument
			 */
			&quot;÷&quot;: (prev) =&gt; {
				return (next) =&gt; {
					this._outputDebug(&quot;init&quot;, &quot;JSXOperatorTokens:div&quot;, prev, next);

					let prevValue = this.Validator.validateNumber(prev, &quot;div&quot;, true);
					let nextValue = this.Validator.validateNumber(next, &quot;div&quot;, true);
					let result = prevValue / nextValue;
					// istanbul ignore next
					this._outputDebug(&quot;result&quot;, &quot;JSXOperatorTokens:div&quot;, prevValue, nextValue, result);
					return result;
				}
			},
			/**
			 * ## mod
			 * modulus
			 * 
			 * &#x60;&#x60;&#x60;js
			 * let path = &#x27;1 mod /b&#x27;;
			 * let result = jsxpth.process(path);
			 * ---------
			 * // result =&gt; 1
			 * &#x60;&#x60;&#x60;
			 * 
			 * @function %
			 * @param  {object|number} prev - the previous parsed value before &#x60;+&#x60;
			 * @return {function} A function that accepts the next parsed value argument
			 */
			&quot;%&quot;: (prev) =&gt; {
				return (next) =&gt; {
					this._outputDebug(&quot;init&quot;, &quot;JSXOperatorTokens:mod&quot;, prev, next);

					let prevValue = this.Validator.validateNumber(prev, &quot;mod&quot;, true);
					let nextValue = this.Validator.validateNumber(next, &quot;mod&quot;, true);
					let result = prevValue % nextValue;
					// istanbul ignore next
					this._outputDebug(&quot;result&quot;, &quot;JSXOperatorTokens:mod&quot;, prevValue, nextValue, result);
					return result;
				}
			},
			/**
			 * ## =
			 * equality
			 * 
			 * &#x60;&#x60;&#x60;js
			 * let path = &#x27;/a = /b&#x27;;
			 * let result = jsxpath.process(path);
			 * ----------
			 * // result =&gt; false
			 * &#x60;&#x60;&#x60;
			 * @function =
			 * @param  {object|number} prev - the previous parsed value before &#x60;+&#x60;
			 * @return {function} A function that accepts the next parsed value argument
			 */
			&quot;=&quot;: (prev) =&gt; {
				return (next) =&gt; {
					this._outputDebug(&quot;init&quot;, &quot;JSXOperatorTokens:=&quot;, prev, next);
					
					let prevValue = this.Validator.validateNumber(prev, &quot;=&quot;);
					let nextValue = this.Validator.validateNumber(next, &quot;=&quot;);

					if (prevValue === null) {
						prevValue = this.Validator.validateString(prev, &quot;=&quot;);
					}
					if (nextValue === null) {
						nextValue = this.Validator.validateString(next, &quot;=&quot;);
					}
					if (prevValue === null) {
						prevValue = this.Validator.isArray(prev, &quot;=&quot;);
					}
					if (nextValue === null) {
						nextValue = this.Validator.isArray(next, &quot;=&quot;);
					}
					if (prevValue === null) {
						prevValue = this.Validator.validateObject(prev, &quot;=&quot;);
					}
					if (nextValue === null) {
						nextValue = this.Validator.validateObject(next, &quot;=&quot;);
					}
					if (prevValue === null) {
						prevValue = this.Validator.validateNode(prev, &quot;=&quot;);
					}
					if (nextValue === null) {
						nextValue = this.Validator.validateNode(next, &quot;=&quot;);
					}

					let result = _.isEqual(prevValue, nextValue);
					// istanbul ignore next
					this._outputDebug(&quot;result&quot;, &quot;JSXOperatorTokens:=&quot;, prevValue, nextValue, result);
					return result;
				}
			},
			/**
			 * ## !=
			 * not equal
			 * 
			 * &#x60;&#x60;&#x60;js
			 * let path = &#x27;/a != /b&#x27;
			 * let result = jsxpath.process(path);
			 * ----------
			 * // result =&gt; true
			 * &#x60;&#x60;&#x60;
			 * 
			 * @function ≠
			 * @param  {object|number} prev - the previous parsed value before &#x60;+&#x60;
			 * @return {function} A function that accepts the next parsed value argument
			 */
			&quot;≠&quot;: (prev) =&gt; {
				return (next) =&gt; {
					this._outputDebug(&quot;init&quot;, &quot;JSXOperatorTokens:≠&quot;, prev, next);

					let prevValue = this.Validator.validateNumber(prev, &quot;=&quot;);
					let nextValue = this.Validator.validateNumber(next, &quot;=&quot;);

					if (prevValue === null) {
						prevValue = this.Validator.validateString(prev, &quot;=&quot;);
					}
					if (nextValue === null) {
						nextValue = this.Validator.validateString(next, &quot;=&quot;);
					}
					if (prevValue === null) {
						prevValue = this.Validator.isArray(prev, &quot;=&quot;);
					}
					if (nextValue === null) {
						nextValue = this.Validator.isArray(next, &quot;=&quot;);
					}
					if (prevValue === null) {
						prevValue = this.Validator.validateNode(prev, &quot;=&quot;);
					}
					if (nextValue === null) {
						nextValue = this.Validator.validateNode(next, &quot;=&quot;);
					}

					let result = !_.isEqual(prevValue, nextValue);
					// istanbul ignore next
					this._outputDebug(&quot;result&quot;, &quot;JSXOperatorTokens:≠&quot;, prevValue, nextValue, result);
					return result;
				}
			},
			/**
			 * ## &gt;
			 * greater than
			 * 
			 * &#x60;&#x60;&#x60;js
			 * let path = &#x27;/a &gt; 1&#x27;;
			 * let result = jaxpath.process(path);
			 * ----------
			 * // result =&gt; false
			 * &#x60;&#x60;&#x60;
			 * 
			 * @function &gt;
			 * @param  {object|number} prev - the previous parsed value before &#x60;+&#x60;
			 * @return {function} A function that accepts the next parsed value argument
			 */
			&quot;&gt;&quot;: (prev) =&gt; {
				return (next) =&gt; {
					this._outputDebug(&quot;init&quot;, &quot;JSXOperatorTokens:&gt;&quot;, prev, next);

					let prevValue = this.Validator.validateNumber(prev, &quot;&gt;&quot;, true);
					let nextValue = this.Validator.validateNumber(next, &quot;&gt;&quot;, true);
					let result = [];
					if (Array.isArray(prevValue) &amp;&amp; Array.isArray(nextValue)) {
						// istanbul ignore next
						this._outputDebug(&quot;result&quot;, &quot;JSXOperatorTokens:&gt;&quot;, prevValue, nextValue, result);
						return result;
					} 

					if (Array.isArray(prevValue)) {
						result = prevValue.filter((e) =&gt; e.value &gt; nextValue);
						// istanbul ignore next
						this._outputDebug(&quot;result&quot;, &quot;JSXOperatorTokens:&gt;&quot;, prevValue, nextValue, result);
						return result;
					} else if (Array.isArray(nextValue)) {
						result = nextValue.filter((e) =&gt; prevValue &gt; e.value);
						// istanbul ignore next
						this._outputDebug(&quot;result&quot;, &quot;JSXOperatorTokens:&gt;&quot;, prevValue, nextValue, result);
						return result;
					}

					result = prevValue &gt; nextValue;
					// istanbul ignore next
					this._outputDebug(&quot;result&quot;, &quot;JSXOperatorTokens:&gt;&quot;, prevValue, nextValue, result);
					return result;
				}
			},
			/**
			 * ## &lt;
			 * less than
			 * 
			 * &#x60;&#x60;&#x60;js
			 * let path = &#x27;/a &lt; 1&#x27;;
			 * let result = jsxpath.process(path);
			 * ----------
			 * // result =&gt; false
			 * &#x60;&#x60;&#x60;
			 * 
			 * @function &lt;
			 * @param  {object|number} prev - the previous parsed value before &#x60;+&#x60;
			 * @return {function} A function that accepts the next parsed value argument
			 */
			&quot;&lt;&quot;: (prev) =&gt; {
				return (next) =&gt; {
					this._outputDebug(&quot;init&quot;, &quot;JSXOperatorTokens:&lt;&quot;, prev, next);

					let prevValue = this.Validator.validateNumber(prev, &quot;&lt;&quot;, true);
					let nextValue = this.Validator.validateNumber(next, &quot;&lt;&quot;, true);
					let result;
					if (Array.isArray(prevValue) &amp;&amp; Array.isArray(nextValue)) {
						// istanbul ignore next
						this._outputDebug(&quot;result&quot;, &quot;JSXOperatorTokens:&lt;&quot;, prevValue, nextValue, []);
						return [];
					} 

					if (Array.isArray(prevValue)) {
						result = prevValue.filter((e) =&gt; e.value &lt; nextValue);
						// istanbul ignore next
						this._outputDebug(&quot;result&quot;, &quot;JSXOperatorTokens:&lt;&quot;, prevValue, nextValue, result);
						return result;
					} else if (Array.isArray(nextValue)) {
						result = nextValue.filter((e) =&gt; prevValue &lt; e.value);
						// istanbul ignore next
						this._outputDebug(&quot;result&quot;, &quot;JSXOperatorTokens:&lt;&quot;, prevValue, nextValue, result);
						return result;
					}

					result = prevValue &lt; nextValue;
					// istanbul ignore next
					this._outputDebug(&quot;result&quot;, &quot;JSXOperatorTokens:&lt;&quot;, prevValue, nextValue, result);
					return result;
				}
			},
			/**
			 * ## &gt;=
			 * greater than or equal to
			 * 
			 * &#x60;&#x60;&#x60;js
			 * let path = &#x27;/a &gt;= 1&#x27;;
			 * let result = jsxpath.process(path);
			 * ----------
			 * // result =&gt; true
			 * &#x60;&#x60;&#x60;
			 * 
			 * @function ≥
			 * @param  {object|number} prev - the previous parsed value before &#x60;+&#x60;
			 * @return {function} A function that accepts the next parsed value argument
			 */
			&quot;≥&quot;: (prev) =&gt; {
				return (next) =&gt; {
					this._outputDebug(&quot;init&quot;, &quot;JSXOperatorTokens:≥&quot;, prev, next);

					let prevValue = this.Validator.validateNumber(prev, &quot;&gt;=&quot;, true);
					let nextValue = this.Validator.validateNumber(next, &quot;&gt;=&quot;, true);
					let result = [];
					if (Array.isArray(prevValue) &amp;&amp; Array.isArray(nextValue)) {
						// istanbul ignore next
						this._outputDebug(&quot;result&quot;, &quot;JSXOperatorTokens:≥&quot;, prevValue, nextValue, result);
						return result;
					} 

					if (Array.isArray(prevValue)) {
						result = prevValue.filter((e) =&gt; e.value &gt;= nextValue);
						// istanbul ignore next
						this._outputDebug(&quot;result&quot;, &quot;JSXOperatorTokens:≥&quot;, prevValue, nextValue, result);
						return result;
					} else if (Array.isArray(nextValue)) {
						result = nextValue.filter((e) =&gt; prevValue &gt;= e.value);
						// istanbul ignore next
						this._outputDebug(&quot;result&quot;, &quot;JSXOperatorTokens:≥&quot;, prevValue, nextValue, result);
						return result;
					}

					result = prevValue &gt;= nextValue;
					// istanbul ignore next
					this._outputDebug(&quot;result&quot;, &quot;JSXOperatorTokens:≥&quot;, prevValue, nextValue, result);
					return result;
				}
			},
			/**
			 * ## &lt;=
			 * less than or equal to
			 * 
			 * &#x60;&#x60;&#x60;js
			 * let path = &#x27;/a &lt;= 1&#x27;;
			 * let result = jsxpath.process(path)
			 * ----------
			 * // result =&gt; true
			 * &#x60;&#x60;&#x60;
			 * 
			 * @function ≤
			 * @param  {object|number} prev - the previous parsed value before &#x60;+&#x60;
			 * @return {function} A function that accepts the next parsed value argument
			 */
			&quot;≤&quot;: (prev) =&gt; {
				return (next) =&gt; {
					// istanbul ignore next
					this._outputDebug(&quot;init&quot;, &quot;JSXOperatorTokens:≤&quot;, prev, next);

					let prevValue = this.Validator.validateNumber(prev, &quot;&lt;=&quot;, true);
					let nextValue = this.Validator.validateNumber(next, &quot;&lt;=&quot;, true);
					let result = [];
					if (Array.isArray(prevValue) &amp;&amp; Array.isArray(nextValue)) {
						// istanbul ignore next
						this._outputDebug(&quot;result&quot;, &quot;JSXOperatorTokens:≤&quot;, prevValue, nextValue, result);
						return result;
					} 

					if (Array.isArray(prevValue)) {
						result = prevValue.filter((e) =&gt; e.value &lt;= nextValue);
						// istanbul ignore next
						this._outputDebug(&quot;result&quot;, &quot;JSXOperatorTokens:≤&quot;, prevValue, nextValue, result);
						return result;
					} else if (Array.isArray(nextValue)) {
						result = nextValue.filter((e) =&gt; prevValue &lt;= e.value);
						// istanbul ignore next
						this._outputDebug(&quot;result&quot;, &quot;JSXOperatorTokens:≤&quot;, prevValue, nextValue, result);
						return result;
					}

					result = prevValue &lt;= nextValue;
					// istanbul ignore next
					this._outputDebug(&quot;result&quot;, &quot;JSXOperatorTokens:≤&quot;, prevValue, nextValue, result);
					return result;
				}
			},
			/**
			 * ## and
			 * logical and
			 * 
			 * &#x60;&#x60;&#x60;js
			 * let path = &#x27;/a and /b&#x27;
			 * let result = jsxpath.process(path)
			 * ----------
			 * // result =&gt; [1, 2]
			 * &#x60;&#x60;&#x60;
			 * 
			 * @function &amp;
			 * @param  {object|number} prev - the previous parsed value before &#x60;+&#x60;
			 * @return {function} A function that accepts the next parsed value argument
			 */
			&quot;&amp;&quot;: (prev) =&gt; {
				return (next) =&gt; {
					// istanbul ignore next
					this._outputDebug(&quot;init&quot;, &quot;JSXOperatorTokens:and&quot;, prev, next);

					let prevValue = this.Validator.validateBoolean(prev, &quot;and&quot;, true);
					let nextValue = this.Validator.validateBoolean(next, &quot;and&quot;, true);
					let result = prevValue &amp;&amp; nextValue;
					// istanbul ignore next
					this._outputDebug(&quot;result&quot;, &quot;JSXOperatorTokens:and&quot;, prevValue, nextValue, result);
					return result;
				}
			},
			/**
			 * ## or
			 * logical or
			 * 
			 * &#x60;&#x60;&#x60;js
			 * let path = &#x27;/a or /b&#x27;;
			 * let result = jsxpath.process(path);
			 * ----------
			 * // result =&gt; [1]
			 * &#x60;&#x60;&#x60;
			 * 
			 * @function Ø
			 * @param  {object|number} prev - the previous parsed value before &#x60;+&#x60;
			 * @return {function} A function that accepts the next parsed value argument
			 */
			&quot;Ø&quot;: (prev) =&gt; {
				return (next) =&gt; {
					// istanbul ignore next
					this._outputDebug(&quot;init&quot;, &quot;JSXOperatorTokens:or&quot;, prev, next);

					let prevValue = this.Validator.validateBoolean(prev, &quot;or&quot;, true);
					let nextValue = this.Validator.validateBoolean(next, &quot;or&quot;, true);
					let result = prevValue || nextValue;
					// istanbul ignore next
					this._outputDebug(&quot;result&quot;, &quot;JSXOperatorTokens:or&quot;, prevValue, nextValue, result);
					return result;
				}
			},
			/**
			 * ## |
			 * union
			 * 
			 * &#x60;&#x60;&#x60;js
			 * let path = &#x27;/a|/c&#x27;;
			 * let result = jsxpath.process(path);
			 * ----------
			 * // result =&gt; [1, [3,  4]]
			 * &#x60;&#x60;&#x60;
			 * 
			 * @function |
			 * @param  {object|number} prev - the previous parsed value before &#x60;+&#x60;
			 * @return {function} A function that accepts the next parsed value argument
			 */
			&quot;|&quot;: (prev) =&gt; {
				return (next) =&gt; {
					// istanbul ignore next
					this._outputDebug(&quot;init&quot;, &quot;JSXOPeratorTokens:|&quot;, prev, next);
					let prevValue = this.Validator.validateNode(prev, &quot;|&quot;);
					let nextValue = this.Validator.validateNode(next, &quot;|&quot;);
					let result = [];
					if (Array.isArray(prevValue) &amp;&amp; Array.isArray(nextValue)) {
						result = prevValue.concat(nextValue);
					} else if (Array.isArray(prevValue)) {
						result = prevValue;
					} else if (Array.isArray(nextValue)) {
						result = nextValue;
					}

					if (prevValue &amp;&amp; !Array.isArray(prevValue)) {
						result.push(prevValue);
					}

					if (nextValue &amp;&amp; !Array.isArray(nextValue)) {
						result.push(nextValue);
					}
					// istanbul ignore next
					this._outputDebug(&quot;result&quot;, &quot;JSXOPeratorTokens:|&quot;, prev, next, result);
					return result;
				}
			}
		}
	}

	keys() {
		return Object.keys(this.tokens);
	}

	/**
	 * @private console log events for debugging purposes
	 * @description console log events for debugging purposes
	 * 
	 * @function _outputDebug 
	 * @param  {string} mode - one of &quot;init&quot; or any
	 * @param  {string} where - the calling location
	 * @param  {object|number} prev - the previous parsed value
	 * @param  {object|number} next - the next parsed value
	 * @param  {any} result the result of the operation
	 * 
	 */
	_outputDebug(mode, where, prev, next, result) {
		// istanbul ignore next
		if (this.DEBUG &amp;&amp; this.SHOW_OPERATOR_TOKENS) {
			let args = [new Date(), where, mode === &quot;init&quot; ? &quot;prev&quot; : &quot;prevValue&quot;, prev, mode === &quot;init&quot; ? &quot;next&quot; : &quot;nextValue&quot;, next];
			if (mode !== &quot;init&quot;) {
				args = args.concat([&quot;result&quot;, result]);
			}
			console.log.apply(this, args);
		}
	}
}

module.exports = JSXOperatorTokens
    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
