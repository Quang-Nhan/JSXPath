<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSXPath.js - JSXPath - xpath query language for JSON documents</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="JSXPath - xpath query language for JSON documents" width="117" height="52">JSXPath - xpath query language for JSON documents</h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 1.2.9</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/JSXAxisTokens.html">JSXAxisTokens</a></li>
                                <li><a href="../classes/JSXOperatorTokens.html">JSXOperatorTokens</a></li>
                                <li><a href="../classes/JSXPath.html">JSXPath</a></li>
                                <li><a href="../classes/JSXPathFunctions.html">JSXPathFunctions</a></li>
                                <li><a href="../classes/JSXProcessor.html">JSXProcessor</a></li>
                                <li><a href="../classes/JSXReplacer.html">JSXReplacer</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/JSXPath.html">JSXPath</a></li>
                                <li><a href="../modules/Parser.html">Parser</a></li>
                                <li><a href="../modules/Processor.html">Processor</a></li>
                                <li><a href="../modules/Tokens.html">Tokens</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: JSXPath.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
var JSXProcessor = require(&quot;./Processor/JSXProcessor&quot;);
const DEBUG = require(&quot;./JSXDebugConfig&quot;).debugOn;

/**
 * JSXPath
 * =======
 * JSXPath is an adaptation of XPath, a querying language for XML documents, to query JSON document.
 * If you are already familiar with the construct of [XPath], using this should be a simple.
 * ### TODO list
 * [ ] Date Time functions
 * [ ] Incorporate Date Time durations into existing operators: -, +, =, != , &gt;, &gt;=, &lt;, &lt;=
 *
 * ## Contents
 * - Home
 *	- [Why JSXPath?](#why-jsx-path)
 *	- [Installation](#installation)
 *	- [Differences &amp; Limitations](#differences-amp-limitations)
 *	- [Features](#features)
 *		- [Predicate Expressions](#predicate-expressions)
 *		- [Variables](#variables)
 *		- [Custom Functions](#custom-functions)
 *		- [Object Comparison](#object-comparison)
 * - [Axis](md/AXIS.html)
 * - [Functions](md/FUNCTIONS.html)
 * - [Node Selection](md/NODESELECTION.html)
 * - [Operators](md/OPERATORS.html)
 *
 * ## Why JSXPath?
 * IF you only require a simple retrieval of a value in an object without the need of interrigating it, eg with the json = { a: 1, b: 2}, to get the value of a, then &#x60;json.a&#x60; is enough. But if you require a more complex conditioning, sure you can write your own functions to handle it, or why not let JSXPath do that?
 * 
 * Example return the value of json.c if the sum of values json.a and json.b is equal to 3;
 * &#x60;&#x60;&#x60;js
 * let js = {a:1, b:2, c: &quot;pass&quot;}
 * //without JSXPath
 * function sum(pa, pb) {
 * if (!isNumber(pa) || isNumber(pb)) {
 *	throw new Error(&quot;an argument is not a number&quot;);
 * }
 * 	return pa + pb;
 * }
 * 
 * function isNumber(num) {
 * 	return !isNaN(num) &amp;&amp; isFinite(num);
 * }
 * 
 * let result = sum(js.a, js.b) === 3 ? js.c : null;
 * ----------
 * // result =&gt; &#x27;pass&#x27;
 *
 * // with JSXPath
 * let JSXPath = require(&quot;JSXPath&quot;);
 * let jsxpath = new JSXPath(json);
 *
 * let path = &#x27;/c[sum(/a, /b) = 3]&#x27;;
 * let result = jsxpath.process(path);
 * ----------
 * // result =&gt; &#x27;pass&#x27;;
 * &#x60;&#x60;&#x60;
 *
 * ## Installation
 *
 * ## Differences &amp; Limitations
 * There are some notable differences and limiations between xml and json that the query langauge do not support.
 * - The &#x27;@&#x27; symbol is not used in JSXPath expression since JSON only consists of key value pair. &#x27;@&#x27; in XML denotes an attribute.
 * - The axis &#x27;preceding&#x27;, &#x27;preceding-sibling&#x27;, &#x27;following&#x27;, and &#x27;following-sibling&#x27; is currently not supported. JSON is a hash map, the keys are not always returned in a particular order. (although future implentations may involve sorting the the node set and returns the relevant siblings and nodes based on this order). 
 * - The operator token keywords are reserved. This means that the keys in the json cannot contain the following symbols (|,/,+, -, %, *, =, &gt;, &lt;) and spaces (future implemenation may cater for this using quotes to denote a key)
 * 
 * ## Features
 *
 * #### Node Selections, Operators, and Axes
 * JSXPath supports most of the expressions found in xpath.
 * 
 * | Node Selection | Operators | Axes 				|
 * | -------------- | --------  | ----------------- |
 * | key  			| &amp;#124; (todo)| self 		|
 * | . 	 		 	| + 		| ancestor 			|
 * | .. 	 		| - 		| ancestor-or-self	|
 * | / 		 	 	| * 		| child				|
 * | // 			| div 		| descendant 		|
 * | *				| = 		| descendant-or-self|
 * | 				| != 		| parent			|
 * | 				| &lt; 		|					|
 * | 				| &lt;= 		|					|
 * | 				| &gt; 		|					|
 * | 				| &gt;= 		|					|
 * | 				| or 		|					|
 * | 				| and 		|					|
 * | 				| mod 		|					|
 *
 * #### Predicate Expressions
 * Predicate expressions are used to filter out node sets based on conditions within &#x27;[&#x27; &#x27;]&#x27;.
 * &#x60;&#x60;&#x60;js
 * let JSXPath = require(&quot;JSXPath&quot;);
 * 
 * let js = {
 * 	tic: 1,
 * 	tac: 10,
 * 	toe: 100,
 * 	foo: {
 * 		tic: 2,
 * 		tac: 20,
 * 		toe: 200
 * 	}
 * };
 * let path = &#x27;/toe[/tic = 1 and /tac &gt; 9]&#x27;;
 * 
 * let jsxpath = new JSXPath(js);
 * let result = jsxpath.process(path);
 * ----------
 * // result =&gt; 100
 *
 * let path = &#x27;//tac[.&gt;1]&#x27;
 * let result = jsxpath.process(path)
 * ----------
 * // result =&gt; [10, 20];
 *
 * let path = &#x27;/toe[/tac = 3]&#x27;
 * let result = jsxpath.process(path);
 * ----------
 * // result =&gt; [];
 * &#x60;&#x60;&#x60;
 * + If the predicate expression resolved to be true, and the result is a single value, then that is returned.
 * + If the predicate expression resolved to be true, and the result contains multiple values, then the returned value will be an array of values.
 * + If the predicate expression resolved to false, then the returned result will be an empty array.
 *
 * #### Variables
 * JSXPath supports variables denoted by the &#x27;$&#x27; sign.
 * The process function accepts a varible object as a second argument.
 * &#x60;&#x60;&#x60;js
 * let JSXPath = require(&quot;JSXPath&quot;);
 *
 * let js = { a: 18 };
 * let path = &#x27;/a + $v1 - $v2&#x27;;
 * let vars = { $v1: 19, $v2: 20 };
 *
 * let jsxpath = new JSXPath(js);
 * let result = jsxpath.process(path, vars);
 * ----------
 * // result =&gt; 17
 * &#x60;&#x60;&#x60;
 * #### Custom Functions
 * Along with predefined JSXPath functions, JSXPath can also support custom functions.
 * The new JSXPath constructor accepts a custom function object as a second argument.
 *
 * &#x60;note&#x60; the custom function will overwrite the predefined functions if they both share the same function name.
 * &#x60;&#x60;&#x60;js
 * let JSXPath = require(&quot;JSXPath&quot;);
 * let customFunctions = {
 *     max: (args, validator) =&gt; {
 * 		let max = validator.validateNumber(args[0], &quot;max()&quot;, true);
 * 		for (let i = 1; i &lt; args.length; i++) {
 * 			let n = validator.validateNumber(args[i], &quot;max()&quot;, true);
 *			if (n &gt; max) {
 *			  max = n;
 *			}
 *		}
 *		return max;
 *     }
 * };
 * let js = {
 * 	a: 1,
 * 	b: 2,
 * 	c: 3
 * };
 * 
 * let jsxpath = new JSXPath(js, customFunctions);
 * let path = &#x27;max(/a, /b, /c)&#x27;;
 * let result = jsxpath.process(path);
 * ----------
 * // result =&gt; 3
 * &#x60;&#x60;&#x60;
 * *__Note:__ the arguments passed in the function can be a number of values:*
 * - a primitive data type (number, string, boolean, undefined, null) value,
 * - a node object in the form of {parent:.., name:..., children:[...], value:...},
 * - an array or a node that has a value of an array of values. TODO: relook at above and this current point.
 *
 * JSXPath provides a number of handy validate helper that can check if an argument is a certain dataType. If it is a valid type then it will return the value otherwise returns null. This can be accessed via the second argument in the custom function.
 *
 * - &#x60;validateString( val, caller, throwError )&#x60;
 * 	- returns the value string if valid otherwise returns null or throw an error if throwError is set to true
 * - &#x60;validateNumber( val, caller, throwError )&#x60;
 *	- returns the number value if valid otherwise returns null or throw an error if throwError is set to true
 * - &#x60;validateNode( val, caller, throwError )&#x60;
 *	- returns the node object if valid otherwise returns null or throw an error if throwError is set to true
 * - &#x60;validateBoolean( val, caller, throwError )&#x60;
 * 	- returns the boolean value if valid otherwise returns null or throw an error if throwError is set to true
 * - &#x60;validateObject( val, caller, throwError )&#x60;
 * 	- returns the object value if valid otherwise returns null or throw an error if throwError is set to true
 * - &#x60;isArray( val, caller, throwError )&#x60;
 * 	- returns the array value if valid otherwise returns null or throw an error if throwError is set to true
 * 
 * The &#x60;val&#x60; argument can either be a primitive, array or a node object value. If it&#x27;s a node object, it will look for and check against val.value in order to determine if it is a valid data type.
 * 
 * #### Object Comparison
 * JSXPath has the ability to compare pure JSON objects in the path expression.
 * &#x60;&#x60;&#x60;js
 * let JSXPath = require(&quot;JSXPath&quot;);
 * let js = {
 * 	a: 1,
 * 	b: {c: 2}
 * };
 * let jsxpath = new JSXPath(js);
 * let path = &#x27;/b = {&quot;c&quot;: 2}&#x27;;
 * let result = jsxpath.process(path);
 * ----------
 * // result =&gt; true
 * &#x60;&#x60;&#x60;
 * //or by using varibles to store the object;
 * 
 * &#x60;&#x60;&#x60;js
 * let vars = { $c: {c:2} };
 * let path = &#x27;/b = $c&#x27;;
 * let result = jsxpath.process(path, vars);
 * ----------
 * // result =&gt; true
 * &#x60;&#x60;&#x60;
 * *__Note:__  The json expression must be a valid json format. Only equal (=) and not equal (!=) can be used for object comparison.
 *
 * 
 * @module JSXPath
 * @class JSXPath 
 * 
 */
class JSXPath {
	constructor(poJSON, poCustomFunctions) {
		this.processor = new JSXProcessor(poCustomFunctions);
		this.json = poJSON || {};
		this.variables = null;
		this.result = null;
		this.history = [];
	}

	/**
	 * 
	 * 
	 * process the variable
	 * @param  {string} psPath - the path to be parsed
	 * @param  {object} poVars - the variable object
	 * @return {array}        an array
	 */
	process(psPath, poVars) {
		this.variables = poVars;
		// istanbul ignore if 
		if (DEBUG) {
			console.log(new Date(), &quot;JSXPath:psPath&quot;, psPath);
			console.log(new Date(), &quot;JSXPath:poVars&quot;, poVars);
		}
		try {
			this.result = this.processor.process(psPath, this.json, poVars);
			this.history.push({
				at: new Date(),
				node: this.result,
				path: psPath,
				variables: poVars &amp;&amp; poVars || null
			});

			// istanbul ignore if 
			if (DEBUG) console.log(new Date(), &quot;JSXPath:result&quot;, this.history[this.history.length-1]);
			
			if (!this.result) {
				return [];
			} else if (this.result !== {}) {
				if (Array.isArray(this.result) &amp;&amp; this.result[0] &amp;&amp; this.result[0].name) {
					this.result.sort((nodeA, nodeB) =&gt; {
						if (nodeA.name === nodeB.name)
							return nodeA.parent &gt; nodeB.parent;
						else 
							return nodeA.name &gt; nodeB.name;
					});
					var result = [];
					for (let i = 0; i &lt; this.result.length; ++i) {
						result.push(this.result[i].value);
					}
					return result;
				} else if (Array.isArray(this.result.value) &amp;&amp; this.result.value.length &amp;&amp; this.result.value[0].name) {
					var result = [];
					for (let i = 0; i &lt; this.result.value.length; ++i) {
						result.push(this.result.value[i].value);
					}
					return result;
				}
					
				return (typeof this.result === &quot;object&quot; &amp;&amp; this.result.hasOwnProperty(&quot;value&quot;)) ? this.result.value : this.result;
			} else {
				return [];
			}
		} catch(e) {
			this.history.push({
				at: new Date(),
				err: e,
				path: psPath,
				variables: poVars &amp;&amp; poVars || null
			});
			console.error(this.history);
		}
	}

	clearHistory() {
		this.history.lenght = 0;
	}

	getLastHistory() {
		return this.history[this.history.length-1];
	}

	getFullHistory() {
		return this.history;
	}
}

module.exports = JSXPath;
    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
