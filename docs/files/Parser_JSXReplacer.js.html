<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Parser/JSXReplacer.js - JSXPath - xpath query language for JSON documents</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="JSXPath - xpath query language for JSON documents" width="117" height="52">JSXPath - xpath query language for JSON documents</h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 1.2.9</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/JSXAxisTokens.html">JSXAxisTokens</a></li>
                                <li><a href="../classes/JSXOperatorTokens.html">JSXOperatorTokens</a></li>
                                <li><a href="../classes/JSXPath.html">JSXPath</a></li>
                                <li><a href="../classes/JSXPathFunctions.html">JSXPathFunctions</a></li>
                                <li><a href="../classes/JSXProcessor.html">JSXProcessor</a></li>
                                <li><a href="../classes/JSXReplacer.html">JSXReplacer</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/JSXPath.html">JSXPath</a></li>
                                <li><a href="../modules/Parser.html">Parser</a></li>
                                <li><a href="../modules/Processor.html">Processor</a></li>
                                <li><a href="../modules/Tokens.html">Tokens</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: Parser/JSXReplacer.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
var JSXError = require(&quot;../Utils/JSXError&quot;)
var JSXDebugConfig = require(&quot;../JSXDebugConfig&quot;);
var JSXUtils = require(&quot;../Utils/JSXUtils&quot;);
var JSXOperatorTokens = require(&quot;../Tokens/JSXOperatorTokens&quot;);

/**
 * @module Parser
 */

/**
 * @class JSXReplacer
 * @constructor
 * @param {Object} poVariables An object containing the defined variables.
 * @param {Object} poJSONKeys The list of keys from the input json.
 */
class JSXReplacer {
	constructor(poVariables, poJSONKeys) {
		this.Utils = new JSXUtils();
		this.Error = new JSXError();
		this.operatorTokensKeys = new JSXOperatorTokens().keys();
		this.variables = poVariables || {};
		this.DEBUG = JSXDebugConfig.debugOn;
		this.SHOW_REPLACER = JSXDebugConfig.showReplacer;
		this.REPLACE_MAP = [ 
			{ key: &quot;{&quot;, when: &quot;preAutoParenthesis&quot;, regex: /\s*\{.*\}(?=[^\}])?/g, with: this._object(&quot;{&quot;, this.variables, []) }
			, { key: &quot;[&quot;, when: &quot;preAutoParenthesis&quot;, regex: /\s*\[.*\](?=[^\]])?/g, with: this._object(&quot;[&quot;, this.variables, this.operatorTokensKeys) }
			, { key: &quot;&#x27;&quot;, when: &quot;preAutoParenthesis&quot;, regex: /(\&#x27;.*\&#x27;)|(\&quot;.*\&quot;)/g, with: this._objectKey(poVariables, poJSONKeys, this.Utils)}
			, { key: &quot;--&quot;, when: &quot;preAutoParenthesis&quot;, regex: /--/g, with: &quot; ¬ ◊&quot;}
			, { key: &quot;-&quot;, when: &quot;preAutoParenthesis&quot;, regex: /-(?![\w|\-]*[\(|\:]|\d+\W)\s*/g, with: &quot; ¬ &quot; }//requires negative lookback to fully function
			, { key: &quot;◊&quot;, when: &quot;preAutoParenthesis&quot;, regex: /◊/g, with: &quot;-&quot; }
			, { key: &quot;/*&quot;, when: &quot;preAutoParenthesis&quot;, regex: /\/\*/g, with: &quot;/Ç&quot; }
			, { key: &quot;::*&quot;, when: &quot;preAutoParenthesis&quot;, regex: /:{2}\*/g, with: &quot;::Ç&quot; }
			, { key: &quot;&gt;=&quot;, when: &quot;preAutoParenthesis&quot;, regex: /\s*(&gt;=|&lt;=|&gt;|&lt;|\||\*|=|!=|\+)\s*/g, with: this._op1() }
			, { key: &quot;and&quot;, when: &quot;preAutoParenthesis&quot;, regex: /\s(and|or|mod|div)\s/g, with: this._op2() }
			, { key: &quot;Ç&quot;, when: &quot;preAutoParenthesis&quot;, regex: /Ç/g, with: &quot;*&quot; }
			, { key: &quot;/&quot;, when: &quot;preAutoParenthesis&quot;, regex: /^\/(?!\/)/g, with:&quot;@/&quot;}
			, { key: &quot;/&quot;, when: &quot;preAutoParenthesis&quot;, regex: /(\+|\÷|\=|\%|\Ø|\&amp;|\≠|\-|\&gt;|\&lt;|\≤|\≥)\/|\s\/(?!\/)/g, with: this._root }
			, { key: &quot;[/&quot;, when: &quot;preAutoParenthesis&quot;, regex: /\[\//g, with: &quot;[@/&quot; }
			, { key: &quot;(/&quot;, when: &quot;preAutoParenthesis&quot;, regex: /\(\//g, with: &quot;(@/&quot; }
			, { key: &quot;//&quot;, when: &quot;postAutoParenthesis&quot;, regex: /(^\/{2}|[\s|\|]\/{2}|\/{2})/g, with: this._descendant}
			, { key: &quot;::&quot;, when: &quot;postAutoParenthesis&quot;, regex:/(\@?[\/|\w|\d|\-]*:{2}[\w|\*|\$]*(\[.*\])*[\.|\/|\w]*)+/g, with: this._axis(this.variables) }
			, { key: &quot;position&quot;, when: &quot;postAutoParenthesis&quot;, regex:/position\(\s*\)\s*\=\s*\d+/g, with: this._position(this.Utils, this.operatorTokensKeys) }
			, { key: &quot;[&quot;, when: &quot;postAutoParenthesis&quot;, regex:/\[\s*\d+\s*(?=\])/g, with: this._position(this.Utils, this.operatorTokensKeys) }
			, { key: &quot;  &quot;, when: &quot;preAutoParenthesis&quot;, regex:/\s{2}/g, with: &quot; &quot; }
		];
	}

	/**
	 * @method replace
	 * @description Performs a series of predefined string replacement of the path expression.
	 * @param  {String} psPath The path expression.
	 * @param  {String} psWhen one of &quot;preAutoParenthesis|postAutoParenthesis&quot;.
	 * @return {String} Transformed psPath.
	 */
	replace(psPath, psWhen) {
		/* istanbul ignore if */
		if (this.DEBUG &amp;&amp; this.SHOW_REPLACER) console.log(new Date(), &quot;JSXReplacer:replace init&quot;, &quot;path:&quot;, psPath, &quot;when:&quot;, psWhen);
		let sPath = psPath;
		for (let i = 0; i &lt; this.REPLACE_MAP.length; ++i) {
			if (this.REPLACE_MAP[i].when === psWhen &amp;&amp; sPath.match(this.REPLACE_MAP[i].regex)) {
				sPath = sPath.replace(this.REPLACE_MAP[i].regex, this.REPLACE_MAP[i].with);
				/* istanbul ignore if */
				if (this.DEBUG &amp;&amp; this.SHOW_REPLACER) console.log(new Date(), &quot;JSXReplacer:replace&quot;, &quot;key:&quot;, this.REPLACE_MAP[i].key, &quot;result:&quot;, sPath);
			}
		}
		return sPath;
	}
	/**
	 * @private
	 * 
	 * @method _op1
	 * @description Replace function for &quot;&gt;=|&lt;=|&gt;|&lt;|\||*|=|!=|+|&quot;
	 * @return {String} 
	 */
	_op1() {
		let map = {
			&quot;&gt;=&quot; : &quot; ≥ &quot;,
			&quot;&lt;=&quot;: &quot; ≤ &quot;,
			&quot;&gt;&quot;: &quot; &gt; &quot;,
			&quot;&lt;&quot;: &quot; &lt; &quot;,
			&quot;|&quot;: &quot; | &quot;,
			&quot;*&quot;: &quot; ~ &quot;,
			&quot;=&quot;: &quot; = &quot;,
			&quot;!=&quot;: &quot; ≠ &quot;,
			&quot;+&quot;: &quot; + &quot;
		}
		return (m, i, o) =&gt;  map[m.trim()];
	}
	/**
	 * @private
	 * 
	 * @method _op2
	 * @description Replace function for &quot;and|or|div|mod&quot; operators.
	 * @return {String}
	 */
	_op2() {
		let map = {
			&quot;and&quot;: &quot; &amp; &quot;,
			&quot;or&quot;: &quot; Ø &quot;,
			&quot;div&quot;: &quot; ÷ &quot;,
			&quot;mod&quot;: &quot; % &quot;
		};
		return (m) =&gt; map[m.trim()];
	}
	/**
	 * @private
	 * 
	 * @method _objectKey
	 * @description Replace function for node name expressions in quotes
	 * @param  {Object} poVariables An object containing the defined variables.
	 * @param  {Object} poKeys The list of keys from the input json.
	 * @param  {Function} Utils Utility function
	 * @return {String}
	 */
	_objectKey(poVariables, poKeys, Utils) {
		// let isInPredicateExpression = (i, o) =&gt; {
		// 	let nBracket = Utils.lastIndexOfString(o, [&quot;[&quot;, &quot;]&quot;], i);
		// 	return nBracket &gt; -1 &amp;&amp; o[nBracket] === &quot;[&quot; ? true : false;
		// };

		// let isInJSONExpression = (m, i, o) =&gt; {
		// 	let sRegex = m + &quot;|{|}&quot;;
		// 	let oRegex = new RegExp(sRegex, &quot;g&quot;);
		// 	let aMatches = o.match(oRegex);
		// 	let nCount = 0;
		// 	for (var i = 0; i &lt; aMatches.length; ++i) {
		// 		if (aMatches[i] === m) {
		// 			break;
		// 		} else if (aMatches[i] === &quot;{&quot;) {
		// 			++nCount;
		// 		} else {
		// 			--nCount;
		// 		}
		// 	}

		// 	return nCount !== 0 ? true : false;
		// }

		return (m, m1, m2, i, o) =&gt; {
			let sSub = o.substring(i+1, i+m.length-1);
			if (poKeys.indexOf(sSub) &gt; -1) {
				poVariables[&quot;$objectKey&quot; + i] = sSub;
				return (&quot;$objectKey&quot; + i);
			}
			return m;
		};
	}
	/**
	 * @privat
	 * 
	 * @method _root
	 * @description Replace function for root expression.
	 * @param  {String} m match
	 * @return {String]}
	 */
	_root(m) {
		return m[0] + &quot; @/&quot;; 
	}
	/**
	 * @private
	 * 
	 * @method _axis
	 * @description Replace function for axis expressions
	 * @param  {Object} poVariables An object containing the defined variables.
	 * @return {String}
	 */
	_axis(poVariables) {
		let objectKey = (k) =&gt; {
			return (k.indexOf(&quot;$&quot;) === 0) &amp;&amp; poVariables.hasOwnProperty(k) ? poVariables[k] : k;
		};

		let transformAxis = (s) =&gt; {
			let asAxisSplits = s.split(&quot;::&quot;);
			if (asAxisSplits[1].includes(&quot;[&quot;)) {
				let nPredStart = asAxisSplits[1].indexOf(&quot;[&quot;);
				let sPred = asAxisSplits[1].substring(nPredStart+1, asAxisSplits[1].length);
				let sNode = asAxisSplits[1].substring(0, nPredStart);
				
				sNode = objectKey(sNode);
				return &quot; &quot; + asAxisSplits[0] + &quot;(&#x27;&quot; + sNode + &quot;&#x27;)&quot; + &quot; [&quot; + sPred;
			} else {
				asAxisSplits[1] = objectKey(asAxisSplits[1]);
				return &quot; &quot; + asAxisSplits[0] + &quot;(&#x27;&quot; + asAxisSplits[1] + &quot;&#x27;)&quot;;
			}
		};

		return (m, m1, m2, i, o) =&gt; {
			let asSplits = m.split(&quot;/&quot;);
			let sAxis = &quot;&quot;;
			for (let i = 0; i &lt; asSplits.length; ++i) {
				if (asSplits[i].includes(&quot;::&quot;)) {
					sAxis += transformAxis(asSplits[i])
				} else if (asSplits[i] === &quot;@&quot;) {
					sAxis += &quot;@&quot;
				} else {
					sAxis += &quot;/&quot; + asSplits[i];
				} 
			}
			return &quot;(&quot; + sAxis + &quot;)&quot;;
		}
	}
	/**
	 * @private
	 * 
	 * @method _position
	 * @description Replace function for position expression
	 * @param  {Function} Utils Utility function
	 * @param  {Array} operatorTokensKeys
	 * @return {String}
	 */
	_position(Utils, operatorTokensKeys) {
		return (m, i, o) =&gt; {
			let nBeg = m.includes(&quot;position&quot;) ? Utils.lastIndexOfString(m, [&quot; &quot;, &quot;=&quot;], m.length) : 1;
			let nEnd = m.length;
			let sPosIndex = m.substring(nBeg, nEnd).trim();
			let sPos = &quot;position(&quot; + sPosIndex + &quot;)&quot;;
			let aKeys = operatorTokensKeys;
			aKeys.push(&quot; &quot;);
			return m[0] === &quot;[&quot; ? m[0] + sPos : sPos;
		}
	}
	/**
	 * @private
	 * 
	 * @method _descendant
	 * @description Replace function for &quot;//&quot;.
	 * @param  {String} m1 Matches.
	 * @param  {String} m2 Match.
	 * @param  {Number} i  Index.
	 * @param  {String} o  Original string.
	 * @return {String}
	 */
	_descendant(m1, m2,  i, o) {
		if (m1[0] === &quot;/&quot; &amp;&amp; (o[i-1] === &quot;(&quot; || i === 0)) {
			return &quot;@/descendant::&quot;
		} else if (m1[0] === &quot; &quot;) {
			return &quot; @/descendant::&quot;;
		}
		return &quot; /descendant::&quot;;
	}
	/**
	 * @private
	 * 
	 * @method _object
	 * @description Replace function for pure object or array expression.
	 * @param  {String} key One of &quot;{|[&quot;
	 * @param  {Object} variables An object containing the defined variables.
	 * @param  {Array} operatorTokenKeys
	 * @return {String}
	 */
	_object(key, variables, operatorTokenKeys) {
		let extractor = this._extractor(key, variables, operatorTokenKeys);

		return (m, i, o) =&gt; {
			let sS = extractor.variablesReplacement(m);
			o = o.replace(m, sS);
			let aS = extractor.extract(sS, i, o);
			if (aS.length) {
				let asS = extractor.prepStrings(aS, sS, i);
				return extractor.composeString(asS);
			}
			return m;
		}
	}
	/**
	 * @private
	 * 
	 * @method _extractor
	 * @description Used by _object function
	 * @param  {String} key                One of &quot;{|[&quot;
	 * @param  {Object} variables          An object containing the defined variables.
	 * @param  {Array} operatorTokensKeys
	 * @return {String}
	 */
	_extractor(key, variables, operatorTokensKeys) {
		let nKey = 0;
		let reverseKey = (key === &quot;[&quot;) ? &quot;]&quot; : &quot;}&quot;;
		let varKey = (key === &quot;[&quot;) ? &quot;$array&quot; : &quot;$object&quot;;
		let updateVariables = (aValue) =&gt; {
			variables[varKey + nKey] = aValue;
		};
		let _prepStrings = (aStrings, sString, i) =&gt; {
			let aS = [];
			for (let j = 0; j &lt; aStrings.length; ++j) {
				updateVariables(aStrings[j].array || aStrings[j].object);
				if (j === 0) aS.push(sString.substring(0, aStrings[j].start-i));
				if (j &gt; 0) aS.push(sString.substring(aStrings[j-1].end+1, aStrings[j].start-i));
				aS.push(varKey + nKey++);
				if (j === aStrings.length-1) aS.push(sString.substring(aStrings[j].end+1-i, sString.length));
			}
			return aS;
	  	};
		let _parse = (sString, i, o, oRay) =&gt; {
			try {
				if (aKeys.includes(o[i-1])) {
					return JSON.parse(sString);
				} else {
					throw new Error(&quot;Invalid array object&quot;)
				}
			} catch(e) {
				return sString;
			}
		};
		let _extract = (sString, i, o) =&gt; {
			let aoStrings = [];
			let oString = {};
			let count = 0;
			for (let j = 0; j &lt; sString.length; ++j) {
				if (sString[j] === key) {
					if (!oString.hasOwnProperty(&quot;start&quot;)) oString.start = j + i;
					++count;
				} else if (sString[j] === reverseKey) {
					--count;
				}
				if (count === 0 &amp;&amp; oString.hasOwnProperty(&quot;start&quot;)) {
					oString.end = j + i;
					let sSub = o.substring(oString.start, oString.end+1);
					if (key === &quot;{&quot;) {
						this.Error.test(&quot;JSON&quot;, {data: sSub, at: &quot;JSXReplacer:_object&quot;});
						oString.object = JSON.parse(sSub);
						aoStrings.push(oString);
					} else {
						let aRay = _parse(sSub, oString.start , o, oString);

						if (Array.isArray(aRay)) {
							oString.array = aRay;
							aoStrings.push(oString);
						} else if (sSub.includes(&quot;[&quot;, 1)) {
							aoStrings = aoStrings.concat(_extract(sSub.substring(1, sSub.length), oString.start + 1, o));
						}
					}
					oString = {};
				}
			}
			return aoStrings;
		};
		let aKeys = operatorTokensKeys;
		aKeys.push(&quot; &quot;);

		return {
			variablesReplacement: (sKey) =&gt; {
				sKey = sKey.replace(/\$[\w|\d]*/g, (m) =&gt; {
					return variables.hasOwnProperty(m) ? JSON.stringify(variables[m]) : m;
				});
				return sKey;
			  }
			, composeString: (aStrings) =&gt; {
				let s = &quot;&quot;;
				for (let i = 0 ; i &lt; aStrings.length; ++i) {
					s += aStrings[i];
				}
				return s;
			  }
			, prepStrings: _prepStrings
			, extract: _extract
			, parse: _parse
		}
	}
}

module.exports = JSXReplacer;
    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
